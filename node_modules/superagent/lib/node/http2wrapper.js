"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
const Stream = require('stream');
const util = require('util');
const net = require('net');
const tls = require('tls');
// eslint-disable-next-line node/no-deprecated-api
const _require = require('url'),
  parse = _require.parse;
const process = require('process');
const semverGte = require('semver/functions/gte');
let http2;
if (semverGte(process.version, 'v10.10.0')) http2 = require('http2');else throw new Error('superagent: this version of Node.js does not support http2');
const _http2$constants = http2.constants,
  HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,
  HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,
  HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,
  HTTP2_HEADER_HOST = _http2$constants.HTTP2_HEADER_HOST,
  HTTP2_HEADER_SET_COOKIE = _http2$constants.HTTP2_HEADER_SET_COOKIE,
  NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;
function setProtocol(protocol) {
  return {
    request(options) {
      return new Request(protocol, options);
    }
  };
}
function Request(protocol, options) {
  Stream.call(this);
  const defaultPort = protocol === 'https:' ? 443 : 80;
  const defaultHost = 'localhost';
  const port = options.port || defaultPort;
  const host = options.host || defaultHost;
  delete options.port;
  delete options.host;
  this.method = options.method;
  this.path = options.path;
  this.protocol = protocol;
  this.host = host;
  delete options.method;
  delete options.path;
  const sessionOptions = _objectSpread({}, options);
  if (options.socketPath) {
    sessionOptions.socketPath = options.socketPath;
    sessionOptions.createConnection = this.createUnixConnection.bind(this);
  }
  this._headers = {};
  const session = http2.connect(`${protocol}//${host}:${port}`, sessionOptions);
  this.setHeader('host', `${host}:${port}`);
  session.on('error', error => this.emit('error', error));
  this.session = session;
}

/**
 * Inherit from `Stream` (which inherits from `EventEmitter`).
 */
util.inherits(Request, Stream);
Request.prototype.createUnixConnection = function (authority, options) {
  switch (this.protocol) {
    case 'http:':
      return net.connect(options.socketPath);
    case 'https:':
      options.ALPNProtocols = ['h2'];
      options.servername = this.host;
      options.allowHalfOpen = true;
      return tls.connect(options.socketPath, options);
    default:
      throw new Error('Unsupported protocol', this.protocol);
  }
};
Request.prototype.setNoDelay = function (bool) {
  // We can not use setNoDelay with HTTP/2.
  // Node 10 limits http2session.socket methods to ones safe to use with HTTP/2.
  // See also https://nodejs.org/api/http2.html#http2_http2session_socket
};
Request.prototype.getFrame = function () {
  if (this.frame) {
    return this.frame;
  }
  const method = {
    [HTTP2_HEADER_PATH]: this.path,
    [HTTP2_HEADER_METHOD]: this.method
  };
  let headers = this.mapToHttp2Header(this._headers);
  headers = Object.assign(headers, method);
  const frame = this.session.request(headers);
  frame.once('response', (headers, flags) => {
    headers = this.mapToHttpHeader(headers);
    frame.headers = headers;
    frame.statusCode = headers[HTTP2_HEADER_STATUS];
    frame.status = frame.statusCode;
    this.emit('response', frame);
  });
  this._headerSent = true;
  frame.once('drain', () => this.emit('drain'));
  frame.on('error', error => this.emit('error', error));
  frame.on('close', () => this.session.close());
  this.frame = frame;
  return frame;
};
Request.prototype.mapToHttpHeader = function (headers) {
  const keys = Object.keys(headers);
  const http2Headers = {};
  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    let key = _keys[_i];
    let value = headers[key];
    key = key.toLowerCase();
    switch (key) {
      case HTTP2_HEADER_SET_COOKIE:
        value = Array.isArray(value) ? value : [value];
        break;
      default:
        break;
    }
    http2Headers[key] = value;
  }
  return http2Headers;
};
Request.prototype.mapToHttp2Header = function (headers) {
  const keys = Object.keys(headers);
  const http2Headers = {};
  for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
    let key = _keys2[_i2];
    let value = headers[key];
    key = key.toLowerCase();
    switch (key) {
      case HTTP2_HEADER_HOST:
        key = HTTP2_HEADER_AUTHORITY;
        value = /^http:\/\/|^https:\/\//.test(value) ? parse(value).host : value;
        break;
      default:
        break;
    }
    http2Headers[key] = value;
  }
  return http2Headers;
};
Request.prototype.setHeader = function (name, value) {
  this._headers[name.toLowerCase()] = value;
};
Request.prototype.getHeader = function (name) {
  return this._headers[name.toLowerCase()];
};
Request.prototype.write = function (data, encoding) {
  const frame = this.getFrame();
  return frame.write(data, encoding);
};
Request.prototype.pipe = function (stream, options) {
  const frame = this.getFrame();
  return frame.pipe(stream, options);
};
Request.prototype.end = function (data) {
  const frame = this.getFrame();
  frame.end(data);
};
Request.prototype.abort = function (data) {
  const frame = this.getFrame();
  frame.close(NGHTTP2_CANCEL);
  this.session.destroy();
};
exports.setProtocol = setProtocol;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTdHJlYW0iLCJyZXF1aXJlIiwidXRpbCIsIm5ldCIsInRscyIsInBhcnNlIiwicHJvY2VzcyIsInNlbXZlckd0ZSIsImh0dHAyIiwidmVyc2lvbiIsIkVycm9yIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX1BBVEgiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwiSFRUUDJfSEVBREVSX01FVEhPRCIsIkhUVFAyX0hFQURFUl9BVVRIT1JJVFkiLCJIVFRQMl9IRUFERVJfSE9TVCIsIkhUVFAyX0hFQURFUl9TRVRfQ09PS0lFIiwiTkdIVFRQMl9DQU5DRUwiLCJzZXRQcm90b2NvbCIsInByb3RvY29sIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJSZXF1ZXN0IiwiY2FsbCIsImRlZmF1bHRQb3J0IiwiZGVmYXVsdEhvc3QiLCJwb3J0IiwiaG9zdCIsIm1ldGhvZCIsInBhdGgiLCJzZXNzaW9uT3B0aW9ucyIsInNvY2tldFBhdGgiLCJjcmVhdGVDb25uZWN0aW9uIiwiY3JlYXRlVW5peENvbm5lY3Rpb24iLCJiaW5kIiwiX2hlYWRlcnMiLCJzZXNzaW9uIiwiY29ubmVjdCIsInNldEhlYWRlciIsIm9uIiwiZXJyb3IiLCJlbWl0IiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJhdXRob3JpdHkiLCJBTFBOUHJvdG9jb2xzIiwic2VydmVybmFtZSIsImFsbG93SGFsZk9wZW4iLCJzZXROb0RlbGF5IiwiYm9vbCIsImdldEZyYW1lIiwiZnJhbWUiLCJoZWFkZXJzIiwibWFwVG9IdHRwMkhlYWRlciIsIk9iamVjdCIsImFzc2lnbiIsIm9uY2UiLCJmbGFncyIsIm1hcFRvSHR0cEhlYWRlciIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJfaGVhZGVyU2VudCIsImNsb3NlIiwia2V5cyIsImh0dHAySGVhZGVycyIsImtleSIsInZhbHVlIiwidG9Mb3dlckNhc2UiLCJBcnJheSIsImlzQXJyYXkiLCJ0ZXN0IiwibmFtZSIsImdldEhlYWRlciIsIndyaXRlIiwiZGF0YSIsImVuY29kaW5nIiwicGlwZSIsInN0cmVhbSIsImVuZCIsImFib3J0IiwiZGVzdHJveSIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvbm9kZS9odHRwMndyYXBwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpXG5jb25zdCB7IHBhcnNlIH0gPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG5jb25zdCBzZW12ZXJHdGUgPSByZXF1aXJlKCdzZW12ZXIvZnVuY3Rpb25zL2d0ZScpO1xuXG5sZXQgaHR0cDI7XG5cbmlmIChzZW12ZXJHdGUocHJvY2Vzcy52ZXJzaW9uLCAndjEwLjEwLjAnKSkgaHR0cDIgPSByZXF1aXJlKCdodHRwMicpO1xuZWxzZVxuICB0aHJvdyBuZXcgRXJyb3IoJ3N1cGVyYWdlbnQ6IHRoaXMgdmVyc2lvbiBvZiBOb2RlLmpzIGRvZXMgbm90IHN1cHBvcnQgaHR0cDInKTtcblxuY29uc3Qge1xuICBIVFRQMl9IRUFERVJfUEFUSCxcbiAgSFRUUDJfSEVBREVSX1NUQVRVUyxcbiAgSFRUUDJfSEVBREVSX01FVEhPRCxcbiAgSFRUUDJfSEVBREVSX0FVVEhPUklUWSxcbiAgSFRUUDJfSEVBREVSX0hPU1QsXG4gIEhUVFAyX0hFQURFUl9TRVRfQ09PS0lFLFxuICBOR0hUVFAyX0NBTkNFTFxufSA9IGh0dHAyLmNvbnN0YW50cztcblxuZnVuY3Rpb24gc2V0UHJvdG9jb2wocHJvdG9jb2wpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdChwcm90b2NvbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBSZXF1ZXN0KHByb3RvY29sLCBvcHRpb25zKSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xuICBjb25zdCBkZWZhdWx0UG9ydCA9IHByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICBjb25zdCBkZWZhdWx0SG9zdCA9ICdsb2NhbGhvc3QnO1xuICBjb25zdCBwb3J0ID0gb3B0aW9ucy5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBjb25zdCBob3N0ID0gb3B0aW9ucy5ob3N0IHx8IGRlZmF1bHRIb3N0O1xuXG4gIGRlbGV0ZSBvcHRpb25zLnBvcnQ7XG4gIGRlbGV0ZSBvcHRpb25zLmhvc3Q7XG5cbiAgdGhpcy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoO1xuICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gIHRoaXMuaG9zdCA9IGhvc3Q7XG5cbiAgZGVsZXRlIG9wdGlvbnMubWV0aG9kO1xuICBkZWxldGUgb3B0aW9ucy5wYXRoO1xuXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gIGlmIChvcHRpb25zLnNvY2tldFBhdGgpIHtcbiAgICBzZXNzaW9uT3B0aW9ucy5zb2NrZXRQYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICAgIHNlc3Npb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSB0aGlzLmNyZWF0ZVVuaXhDb25uZWN0aW9uLmJpbmQodGhpcyk7XG4gIH1cblxuICB0aGlzLl9oZWFkZXJzID0ge307XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IGh0dHAyLmNvbm5lY3QoYCR7cHJvdG9jb2x9Ly8ke2hvc3R9OiR7cG9ydH1gLCBzZXNzaW9uT3B0aW9ucyk7XG4gIHRoaXMuc2V0SGVhZGVyKCdob3N0JywgYCR7aG9zdH06JHtwb3J0fWApO1xuXG4gIHNlc3Npb24ub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcblxuICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xufVxuXG4vKipcbiAqIEluaGVyaXQgZnJvbSBgU3RyZWFtYCAod2hpY2ggaW5oZXJpdHMgZnJvbSBgRXZlbnRFbWl0dGVyYCkuXG4gKi9cbnV0aWwuaW5oZXJpdHMoUmVxdWVzdCwgU3RyZWFtKTtcblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlVW5peENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoYXV0aG9yaXR5LCBvcHRpb25zKSB7XG4gIHN3aXRjaCAodGhpcy5wcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zLnNvY2tldFBhdGgpO1xuICAgIGNhc2UgJ2h0dHBzOic6XG4gICAgICBvcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XG4gICAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSB0aGlzLmhvc3Q7XG4gICAgICBvcHRpb25zLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMuc29ja2V0UGF0aCwgb3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wnLCB0aGlzLnByb3RvY29sKTtcbiAgfVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uIChib29sKSB7XG4gIC8vIFdlIGNhbiBub3QgdXNlIHNldE5vRGVsYXkgd2l0aCBIVFRQLzIuXG4gIC8vIE5vZGUgMTAgbGltaXRzIGh0dHAyc2Vzc2lvbi5zb2NrZXQgbWV0aG9kcyB0byBvbmVzIHNhZmUgdG8gdXNlIHdpdGggSFRUUC8yLlxuICAvLyBTZWUgYWxzbyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAyLmh0bWwjaHR0cDJfaHR0cDJzZXNzaW9uX3NvY2tldFxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWU7XG4gIH1cblxuICBjb25zdCBtZXRob2QgPSB7XG4gICAgW0hUVFAyX0hFQURFUl9QQVRIXTogdGhpcy5wYXRoLFxuICAgIFtIVFRQMl9IRUFERVJfTUVUSE9EXTogdGhpcy5tZXRob2RcbiAgfTtcblxuICBsZXQgaGVhZGVycyA9IHRoaXMubWFwVG9IdHRwMkhlYWRlcih0aGlzLl9oZWFkZXJzKTtcblxuICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBtZXRob2QpO1xuXG4gIGNvbnN0IGZyYW1lID0gdGhpcy5zZXNzaW9uLnJlcXVlc3QoaGVhZGVycyk7XG5cbiAgZnJhbWUub25jZSgncmVzcG9uc2UnLCAoaGVhZGVycywgZmxhZ3MpID0+IHtcbiAgICBoZWFkZXJzID0gdGhpcy5tYXBUb0h0dHBIZWFkZXIoaGVhZGVycyk7XG4gICAgZnJhbWUuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgZnJhbWUuc3RhdHVzQ29kZSA9IGhlYWRlcnNbSFRUUDJfSEVBREVSX1NUQVRVU107XG4gICAgZnJhbWUuc3RhdHVzID0gZnJhbWUuc3RhdHVzQ29kZTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgZnJhbWUpO1xuICB9KTtcblxuICB0aGlzLl9oZWFkZXJTZW50ID0gdHJ1ZTtcblxuICBmcmFtZS5vbmNlKCdkcmFpbicsICgpID0+IHRoaXMuZW1pdCgnZHJhaW4nKSk7XG4gIGZyYW1lLm9uKCdlcnJvcicsIChlcnJvcikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKSk7XG4gIGZyYW1lLm9uKCdjbG9zZScsICgpID0+IHRoaXMuc2Vzc2lvbi5jbG9zZSgpKTtcblxuICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gIHJldHVybiBmcmFtZTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLm1hcFRvSHR0cEhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgY29uc3QgaHR0cDJIZWFkZXJzID0ge307XG4gIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgbGV0IHZhbHVlID0gaGVhZGVyc1trZXldO1xuICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIEhUVFAyX0hFQURFUl9TRVRfQ09PS0lFOlxuICAgICAgICB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGh0dHAySGVhZGVyc1trZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gaHR0cDJIZWFkZXJzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUubWFwVG9IdHRwMkhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgY29uc3QgaHR0cDJIZWFkZXJzID0ge307XG4gIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgbGV0IHZhbHVlID0gaGVhZGVyc1trZXldO1xuICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIEhUVFAyX0hFQURFUl9IT1NUOlxuICAgICAgICBrZXkgPSBIVFRQMl9IRUFERVJfQVVUSE9SSVRZO1xuICAgICAgICB2YWx1ZSA9IC9eaHR0cDpcXC9cXC98Xmh0dHBzOlxcL1xcLy8udGVzdCh2YWx1ZSlcbiAgICAgICAgICA/IHBhcnNlKHZhbHVlKS5ob3N0XG4gICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBodHRwMkhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGh0dHAySGVhZGVycztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZykge1xuICBjb25zdCBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoKTtcbiAgcmV0dXJuIGZyYW1lLndyaXRlKGRhdGEsIGVuY29kaW5nKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoc3RyZWFtLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZyYW1lID0gdGhpcy5nZXRGcmFtZSgpO1xuICByZXR1cm4gZnJhbWUucGlwZShzdHJlYW0sIG9wdGlvbnMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZnJhbWUgPSB0aGlzLmdldEZyYW1lKCk7XG4gIGZyYW1lLmVuZChkYXRhKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZnJhbWUgPSB0aGlzLmdldEZyYW1lKCk7XG4gIGZyYW1lLmNsb3NlKE5HSFRUUDJfQ0FOQ0VMKTtcbiAgdGhpcy5zZXNzaW9uLmRlc3Ryb3koKTtcbn07XG5cbmV4cG9ydHMuc2V0UHJvdG9jb2wgPSBzZXRQcm90b2NvbDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxNQUFNLEdBQUdDLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDaEMsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU1FLEdBQUcsR0FBR0YsT0FBTyxD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